"use strict";(globalThis.webpackChunkai_robotics_book=globalThis.webpackChunkai_robotics_book||[]).push([[2926],{3843:(n,e,i)=>{i.d(e,{A:()=>s});const s=i.p+"assets/images/ch9-flow-4e6590e50111eebaacce1bbfa2964cdd.svg"},7156:(n,e,i)=>{i.d(e,{A:()=>s});const s=i.p+"assets/images/ch9-ad-9a24c9a83fe2139419f1ded4716d7971.svg"},7634:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>t,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module2_simulation/sensors-and-physics-in-simulation","title":"Sensors and Physics in Simulation","description":"Learning Objectives","source":"@site/docs/module2_simulation/09-sensors-and-physics-in-simulation.md","sourceDirName":"module2_simulation","slug":"/module2_simulation/sensors-and-physics-in-simulation","permalink":"/Physical-AI-and-Humanoid-Robotics-Book/docs/module2_simulation/sensors-and-physics-in-simulation","draft":false,"unlisted":false,"editUrl":"https://github.com/Iqrasajid-01/docs/module2_simulation/09-sensors-and-physics-in-simulation.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"title":"Sensors and Physics in Simulation","sidebar_label":"09 - Sensors and Physics in Simulation"},"sidebar":"tutorialSidebar","previous":{"title":"08 - Robot Modeling with URDF","permalink":"/Physical-AI-and-Humanoid-Robotics-Book/docs/module2_simulation/robot-modeling-with-urdf"},"next":{"title":"10 - Unity Isaac Sim Basics","permalink":"/Physical-AI-and-Humanoid-Robotics-Book/docs/module2_simulation/unity-isaac-sim-basics"}}');var a=i(4848),r=i(8453);const o={title:"Sensors and Physics in Simulation",sidebar_label:"09 - Sensors and Physics in Simulation"},t="Sensors and Physics in Simulation",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Physics Engines in Gazebo",id:"physics-engines-in-gazebo",level:3},{value:"Physics Properties",id:"physics-properties",level:3},{value:"Sensor Types in Gazebo",id:"sensor-types-in-gazebo",level:3},{value:"Sensor Noise Modeling",id:"sensor-noise-modeling",level:3},{value:"Architecture Diagram",id:"architecture-diagram",level:2},{value:"Flow Diagram",id:"flow-diagram",level:2},{value:"Code Example: Sensor Configuration in URDF",id:"code-example-sensor-configuration-in-urdf",level:2},{value:"Code Example: Physics Configuration in World Files",id:"code-example-physics-configuration-in-world-files",level:2},{value:"Step-by-Step Practical Tutorial",id:"step-by-step-practical-tutorial",level:2},{value:"Configuring Sensors and Physics in Simulation",id:"configuring-sensors-and-physics-in-simulation",level:3},{value:"Summary",id:"summary",level:2},{value:"Mini-Quiz",id:"mini-quiz",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"sensors-and-physics-in-simulation",children:"Sensors and Physics in Simulation"})}),"\n",(0,a.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Understand how physics engines simulate real-world physics in Gazebo"}),"\n",(0,a.jsx)(e.li,{children:"Configure and implement various sensor types in simulation"}),"\n",(0,a.jsx)(e.li,{children:"Model sensor noise and uncertainty in simulated environments"}),"\n",(0,a.jsx)(e.li,{children:"Integrate physics properties with robot models for realistic simulation"}),"\n",(0,a.jsx)(e.li,{children:"Evaluate the accuracy and limitations of simulated sensors and physics"}),"\n",(0,a.jsx)(e.li,{children:"Optimize simulation performance while maintaining accuracy"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(e.p,{children:"Realistic simulation of sensors and physics is crucial for developing and testing robotic systems. Gazebo provides sophisticated physics engines and sensor simulation capabilities that allow developers to create environments that closely mimic real-world conditions. Understanding how to configure these elements properly is essential for effective sim-to-real transfer."}),"\n",(0,a.jsx)(e.p,{children:"The quality of sensor and physics simulation directly impacts the validity of testing results and the success of algorithms when deployed on real robots. This chapter explores the underlying principles and practical implementation of sensors and physics in Gazebo simulation."}),"\n",(0,a.jsx)(e.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,a.jsx)(e.h3,{id:"physics-engines-in-gazebo",children:"Physics Engines in Gazebo"}),"\n",(0,a.jsx)(e.p,{children:"Gazebo supports multiple physics engines:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"ODE (Open Dynamics Engine)"}),": Default engine, good for most applications"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Bullet"}),": Fast, stable, good for articulated bodies"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"DART (Dynamic Animation and Robotics Toolkit)"}),": Advanced contact modeling"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"physics-properties",children:"Physics Properties"}),"\n",(0,a.jsx)(e.p,{children:"Key physics parameters include:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Gravity"}),": Global gravitational acceleration"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Friction"}),": Surface interaction properties (mu1, mu2)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Damping"}),": Energy dissipation parameters"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Mass and Inertia"}),": Dynamic properties of objects"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Collision Properties"}),": Contact behavior and restitution"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"sensor-types-in-gazebo",children:"Sensor Types in Gazebo"}),"\n",(0,a.jsx)(e.p,{children:"Gazebo provides simulation for various sensor types:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Camera Sensors"}),": RGB, depth, and stereo cameras"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"LIDAR"}),": 2D and 3D laser range finders"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"IMU"}),": Inertial measurement units"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"GPS"}),": Global positioning system"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Force/Torque"}),": Joint force and torque sensors"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Contact Sensors"}),": Collision detection sensors"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"sensor-noise-modeling",children:"Sensor Noise Modeling"}),"\n",(0,a.jsx)(e.p,{children:"Realistic sensor simulation includes:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Gaussian Noise"}),": Random measurement errors"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Bias"}),": Systematic measurement errors"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Drift"}),": Time-varying systematic errors"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Latency"}),": Time delays in sensor readings"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Resolution"}),": Discretization effects"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"architecture-diagram",children:"Architecture Diagram"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.img,{alt:"Architecture Diagram",src:i(7156).A+"",width:"1793",height:"685"})}),"\n",(0,a.jsx)(e.h2,{id:"flow-diagram",children:"Flow Diagram"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.img,{alt:"Architecture Diagram",src:i(3843).A+"",width:"1269",height:"495"})}),"\n",(0,a.jsx)(e.h2,{id:"code-example-sensor-configuration-in-urdf",children:"Code Example: Sensor Configuration in URDF"}),"\n",(0,a.jsx)(e.p,{children:"Here's an example of configuring various sensors in a URDF model:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="robot_with_sensors" xmlns:xacro="http://www.ros.org/wiki/xacro">\n  \x3c!-- Base link --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <cylinder radius="0.2" length="0.15"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 1 0.8"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.2" length="0.15"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="10.0"/>\n      <inertia ixx="0.4" ixy="0" ixz="0" iyy="0.4" iyz="0" izz="0.2"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Camera link --\x3e\n  <link name="camera_link">\n    <visual>\n      <geometry>\n        <box size="0.05 0.05 0.05"/>\n      </geometry>\n      <material name="black">\n        <color rgba="0 0 0 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.05 0.05 0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.1"/>\n      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Camera joint --\x3e\n  <joint name="camera_joint" type="fixed">\n    <parent link="base_link"/>\n    <child link="camera_link"/>\n    <origin xyz="0.15 0 0.1" rpy="0 0 0"/>\n  </joint>\n\n  \x3c!-- IMU link --\x3e\n  <link name="imu_link">\n    <inertial>\n      <mass value="0.01"/>\n      <inertia ixx="0.0001" ixy="0" ixz="0" iyy="0.0001" iyz="0" izz="0.0001"/>\n    </inertial>\n  </link>\n\n  \x3c!-- IMU joint --\x3e\n  <joint name="imu_joint" type="fixed">\n    <parent link="base_link"/>\n    <child link="imu_link"/>\n    <origin xyz="0 0 0.05" rpy="0 0 0"/>\n  </joint>\n\n  \x3c!-- LIDAR link --\x3e\n  <link name="lidar_link">\n    <visual>\n      <geometry>\n        <cylinder radius="0.05" length="0.04"/>\n      </geometry>\n      <material name="red">\n        <color rgba="1 0 0 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.05" length="0.04"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.2"/>\n      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.002"/>\n    </inertial>\n  </link>\n\n  \x3c!-- LIDAR joint --\x3e\n  <joint name="lidar_joint" type="fixed">\n    <parent link="base_link"/>\n    <child link="lidar_link"/>\n    <origin xyz="0.15 0 0.1" rpy="0 0 0"/>\n  </joint>\n\n  \x3c!-- Gazebo plugins for sensors --\x3e\n  <gazebo reference="camera_link">\n    <sensor type="camera" name="camera1">\n      <update_rate>30.0</update_rate>\n      <camera name="head">\n        <horizontal_fov>1.3962634</horizontal_fov>\n        <image>\n          <width>800</width>\n          <height>600</height>\n          <format>R8G8B8</format>\n        </image>\n        <clip>\n          <near>0.02</near>\n          <far>300</far>\n        </clip>\n        <noise>\n          <type>gaussian</type>\n          <mean>0.0</mean>\n          <stddev>0.007</stddev>\n        </noise>\n      </camera>\n      <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\n        <ros>\n          <namespace>/camera</namespace>\n          <remapping>~/image_raw:=image_raw</remapping>\n          <remapping>~/camera_info:=camera_info</remapping>\n        </ros>\n        <camera_name>camera</camera_name>\n        <image_topic_name>image_raw</image_topic_name>\n        <camera_info_topic_name>camera_info</camera_info_topic_name>\n        <frame_name>camera_link</frame_name>\n        <hack_baseline>0.07</hack_baseline>\n        <distortion_k1>0.0</distortion_k1>\n        <distortion_k2>0.0</distortion_k2>\n        <distortion_k3>0.0</distortion_k3>\n        <distortion_t1>0.0</distortion_t1>\n        <distortion_t2>0.0</distortion_t2>\n      </plugin>\n    </sensor>\n  </gazebo>\n\n  <gazebo reference="imu_link">\n    <sensor name="imu_sensor" type="imu">\n      <always_on>true</always_on>\n      <update_rate>100</update_rate>\n      <visualize>true</visualize>\n      <imu>\n        <angular_velocity>\n          <x>\n            <noise type="gaussian">\n              <mean>0.0</mean>\n              <stddev>2e-4</stddev>\n              <bias_mean>0.0000075</bias_mean>\n              <bias_stddev>0.0000008</bias_stddev>\n            </noise>\n          </x>\n          <y>\n            <noise type="gaussian">\n              <mean>0.0</mean>\n              <stddev>2e-4</stddev>\n              <bias_mean>0.0000075</bias_mean>\n              <bias_stddev>0.0000008</bias_stddev>\n            </noise>\n          </y>\n          <z>\n            <noise type="gaussian">\n              <mean>0.0</mean>\n              <stddev>2e-4</stddev>\n              <bias_mean>0.0000075</bias_mean>\n              <bias_stddev>0.0000008</bias_stddev>\n            </noise>\n          </z>\n        </angular_velocity>\n        <linear_acceleration>\n          <x>\n            <noise type="gaussian">\n              <mean>0.0</mean>\n              <stddev>1.7e-2</stddev>\n              <bias_mean>0.1</bias_mean>\n              <bias_stddev>0.001</bias_stddev>\n            </noise>\n          </x>\n          <y>\n            <noise type="gaussian">\n              <mean>0.0</mean>\n              <stddev>1.7e-2</stddev>\n              <bias_mean>0.1</bias_mean>\n              <bias_stddev>0.001</bias_stddev>\n            </noise>\n          </y>\n          <z>\n            <noise type="gaussian">\n              <mean>0.0</mean>\n              <stddev>1.7e-2</stddev>\n              <bias_mean>0.1</bias_mean>\n              <bias_stddev>0.001</bias_stddev>\n            </noise>\n          </z>\n        </linear_acceleration>\n      </imu>\n      <plugin name="imu_plugin" filename="libgazebo_ros_imu_sensor.so">\n        <ros>\n          <namespace>/imu</namespace>\n          <remapping>~/out:=data</remapping>\n        </ros>\n        <frame_name>imu_link</frame_name>\n        <initial_orientation_as_reference>false</initial_orientation_as_reference>\n      </plugin>\n    </sensor>\n  </gazebo>\n\n  <gazebo reference="lidar_link">\n    <sensor name="lidar_sensor" type="ray">\n      <always_on>true</always_on>\n      <visualize>true</visualize>\n      <update_rate>10</update_rate>\n      <ray>\n        <scan>\n          <horizontal>\n            <samples>720</samples>\n            <resolution>1</resolution>\n            <min_angle>-1.570796</min_angle>\n            <max_angle>1.570796</max_angle>\n          </horizontal>\n        </scan>\n        <range>\n          <min>0.10</min>\n          <max>30.0</max>\n          <resolution>0.01</resolution>\n        </range>\n        <noise>\n          <type>gaussian</type>\n          <mean>0.0</mean>\n          <stddev>0.01</stddev>\n        </noise>\n      </ray>\n      <plugin name="lidar_plugin" filename="libgazebo_ros_ray_sensor.so">\n        <ros>\n          <namespace>/lidar</namespace>\n          <remapping>~/out:=scan</remapping>\n        </ros>\n        <output_type>sensor_msgs/LaserScan</output_type>\n        <frame_name>lidar_link</frame_name>\n      </plugin>\n    </sensor>\n  </gazebo>\n\n  \x3c!-- Gazebo physics properties --\x3e\n  <gazebo reference="base_link">\n    <material>Gazebo/Blue</material>\n    <mu1>0.2</mu1>\n    <mu2>0.2</mu2>\n    <kp>1000000.0</kp>\n    <kd>1.0</kd>\n  </gazebo>\n</robot>\n'})}),"\n",(0,a.jsx)(e.h2,{id:"code-example-physics-configuration-in-world-files",children:"Code Example: Physics Configuration in World Files"}),"\n",(0,a.jsx)(e.p,{children:"Here's an example of configuring physics properties in a Gazebo world file:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="default">\n    \x3c!-- Physics engine configuration --\x3e\n    <physics name="1ms" type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n      <gravity>0 0 -9.8</gravity>\n      <ode>\n        <solver>\n          <type>quick</type>\n          <iters>10</iters>\n          <sor>1.3</sor>\n        </solver>\n        <constraints>\n          <cfm>0.0</cfm>\n          <erp>0.2</erp>\n          <contact_max_correcting_vel>100</contact_max_correcting_vel>\n          <contact_surface_layer>0.001</contact_surface_layer>\n        </constraints>\n      </ode>\n    </physics>\n\n    \x3c!-- Include a ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Include sun for lighting --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- Define a simple box model --\x3e\n    <model name="box">\n      <pose>0 0 0.5 0 0 0</pose>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <box>\n              <size>1 1 1</size>\n            </box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box>\n              <size>1 1 1</size>\n            </box>\n          </geometry>\n        </visual>\n        <inertial>\n          <mass>1.0</mass>\n          <inertia>\n            <ixx>0.166667</ixx>\n            <ixy>0</ixy>\n            <ixz>0</ixz>\n            <iyy>0.166667</iyy>\n            <iyz>0</iyz>\n            <izz>0.166667</izz>\n          </inertia>\n        </inertial>\n      </link>\n    </model>\n  </world>\n</sdf>\n'})}),"\n",(0,a.jsx)(e.h2,{id:"step-by-step-practical-tutorial",children:"Step-by-Step Practical Tutorial"}),"\n",(0,a.jsx)(e.h3,{id:"configuring-sensors-and-physics-in-simulation",children:"Configuring Sensors and Physics in Simulation"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Create a sensor configuration package"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"cd ~/ros2_ws/src\nros2 pkg create --build-type ament_cmake robot_sensors_config --dependencies rclpy std_msgs sensor_msgs\n"})}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Create the directory structure"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"cd robot_sensors_config\nmkdir -p urdf config launch worlds\n"})}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Create a robot model with sensors"})," (",(0,a.jsx)(e.code,{children:"urdf/sensor_robot.urdf"}),"):"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:"\x3c!-- Use the sensor configuration URDF example above --\x3e\n"})}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Create a custom world file"})," (",(0,a.jsx)(e.code,{children:"worlds/sensor_test.world"}),"):"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Use the world file example above with modifications --\x3e\n<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="sensor_test_world">\n    \x3c!-- Physics engine configuration --\x3e\n    <physics name="1ms" type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n      <gravity>0 0 -9.8</gravity>\n      <ode>\n        <solver>\n          <type>quick</type>\n          <iters>10</iters>\n          <sor>1.3</sor>\n        </solver>\n        <constraints>\n          <cfm>0.0</cfm>\n          <erp>0.2</erp>\n          <contact_max_correcting_vel>100</contact_max_correcting_vel>\n          <contact_surface_layer>0.001</contact_surface_layer>\n        </constraints>\n      </ode>\n    </physics>\n\n    \x3c!-- Include a ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Include sun for lighting --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- Add some objects for sensor testing --\x3e\n    <model name="wall_1">\n      <pose>3 0 1 0 0 0</pose>\n      <link name="wall_link">\n        <collision name="collision">\n          <geometry>\n            <box>\n              <size>0.1 6 2</size>\n            </box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box>\n              <size>0.1 6 2</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>0.5 0.5 0.5 1</ambient>\n            <diffuse>0.8 0.8 0.8 1</diffuse>\n          </material>\n        </visual>\n        <inertial>\n          <mass>100.0</mass>\n          <inertia>\n            <ixx>100</ixx>\n            <ixy>0</ixy>\n            <ixz>0</ixz>\n            <iyy>100</iyy>\n            <iyz>0</iyz>\n            <izz>100</izz>\n          </inertia>\n        </inertial>\n      </link>\n    </model>\n  </world>\n</sdf>\n'})}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Create a launch file for the simulation"})," (",(0,a.jsx)(e.code,{children:"launch/sensor_simulation.launch.py"}),"):"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\nimport os\nfrom ament_index_python.packages import get_package_share_directory\n\n\ndef generate_launch_description():\n    # Declare launch arguments\n    use_sim_time = LaunchConfiguration('use_sim_time', default='true')\n    world = LaunchConfiguration('world', default='sensor_test.world')\n\n    # Get package share directory\n    pkg_share = get_package_share_directory('robot_sensors_config')\n    default_world_path = os.path.join(pkg_share, 'worlds', 'sensor_test.world')\n    robot_urdf_path = os.path.join(pkg_share, 'urdf', 'sensor_robot.urdf')\n\n    return LaunchDescription([\n        # Declare launch arguments\n        DeclareLaunchArgument(\n            'use_sim_time',\n            default_value='true',\n            description='Use simulation (Gazebo) clock if true'),\n\n        DeclareLaunchArgument(\n            'world',\n            default_value=default_world_path,\n            description='Full path to world file to load'),\n\n        # Start Gazebo server\n        IncludeLaunchDescription(\n            PythonLaunchDescriptionSource([\n                PathJoinSubstitution([\n                    FindPackageShare('gazebo_ros'),\n                    'launch',\n                    'gzserver.launch.py'\n                ])\n            ]),\n            launch_arguments={\n                'world': world,\n                'verbose': 'false',\n            }.items()\n        ),\n\n        # Start Gazebo client\n        IncludeLaunchDescription(\n            PythonLaunchDescriptionSource([\n                PathJoinSubstitution([\n                    FindPackageShare('gazebo_ros'),\n                    'launch',\n                    'gzclient.launch.py'\n                ])\n            ]),\n        ),\n\n        # Robot state publisher\n        Node(\n            package='robot_state_publisher',\n            executable='robot_state_publisher',\n            name='robot_state_publisher',\n            output='screen',\n            parameters=[{\n                'use_sim_time': use_sim_time,\n                'robot_description': open(robot_urdf_path).read()\n            }]),\n\n        # Spawn robot in Gazebo\n        Node(\n            package='gazebo_ros',\n            executable='spawn_entity.py',\n            arguments=[\n                '-topic', 'robot_description',\n                '-entity', 'sensor_robot',\n                '-x', '0', '-y', '0', '-z', '0.2'\n            ],\n            output='screen'),\n    ])\n"})}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Update package.xml"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>\n<package format="3">\n  <name>robot_sensors_config</name>\n  <version>0.0.0</version>\n  <description>Package for sensor and physics configuration examples</description>\n  <maintainer email="user@example.com">User</maintainer>\n  <license>Apache-2.0</license>\n\n  <buildtool_depend>ament_cmake</buildtool_depend>\n\n  <depend>rclpy</depend>\n  <depend>std_msgs</depend>\n  <depend>sensor_msgs</depend>\n  <depend>robot_state_publisher</depend>\n  <depend>gazebo_ros</depend>\n  <depend>gazebo_plugins</depend>\n\n  <export>\n    <build_type>ament_cmake</build_type>\n  </export>\n</package>\n'})}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Update CMakeLists.txt"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-cmake",children:'cmake_minimum_required(VERSION 3.8)\nproject(robot_sensors_config)\n\nif(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")\n  add_compile_options(-Wall -Wextra -Wpedantic)\nendif()\n\n# Find dependencies\nfind_package(ament_cmake REQUIRED)\nfind_package(rclpy REQUIRED)\nfind_package(std_msgs REQUIRED)\nfind_package(sensor_msgs REQUIRED)\nfind_package(robot_state_publisher REQUIRED)\nfind_package(gazebo_ros REQUIRED)\nfind_package(gazebo_plugins REQUIRED)\n\n# Install files\ninstall(DIRECTORY\n  launch\n  urdf\n  worlds\n  config\n  DESTINATION share/${PROJECT_NAME}\n)\n\nament_package()\n'})}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Build the package"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"cd ~/ros2_ws\ncolcon build --packages-select robot_sensors_config\n"})}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Source the workspace"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"source install/setup.bash\n"})}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Launch the simulation with sensors"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"ros2 launch robot_sensors_config sensor_simulation.launch.py\n"})}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"In another terminal, check the sensor topics"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:'ros2 topic list | grep -E "(camera|imu|scan)"\n'})}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"View sensor data"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"# Camera images\nros2 run image_view image_view _image:=/camera/image_raw\n\n# IMU data\nros2 topic echo /imu/data\n\n# LIDAR scans\nros2 topic echo /lidar/scan\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(e.p,{children:"This chapter explored the simulation of sensors and physics in Gazebo, which are critical for realistic robot simulation. We covered how to configure various sensor types, model sensor noise and uncertainty, and set up physics properties for accurate simulation."}),"\n",(0,a.jsx)(e.p,{children:"Proper sensor and physics configuration is essential for effective sim-to-real transfer, allowing algorithms developed in simulation to work effectively on real robots. Understanding these concepts enables the creation of realistic testing environments for robotic systems."}),"\n",(0,a.jsx)(e.h2,{id:"mini-quiz",children:"Mini-Quiz"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"Which physics engines are supported by Gazebo?"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"A) ODE only"}),"\n",(0,a.jsx)(e.li,{children:"B) Bullet only"}),"\n",(0,a.jsx)(e.li,{children:"C) ODE, Bullet, and DART"}),"\n",(0,a.jsx)(e.li,{children:"D) Custom engine only"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"Which sensor type would be best for 3D mapping?"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"A) IMU"}),"\n",(0,a.jsx)(e.li,{children:"B) 2D LIDAR"}),"\n",(0,a.jsx)(e.li,{children:"C) 3D LIDAR or stereo camera"}),"\n",(0,a.jsx)(e.li,{children:"D) GPS"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"What does the max_step_size parameter control in physics configuration?"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"A) Maximum speed of the robot"}),"\n",(0,a.jsx)(e.li,{children:"B) Time step for physics simulation"}),"\n",(0,a.jsx)(e.li,{children:"C) Maximum sensor range"}),"\n",(0,a.jsx)(e.li,{children:"D) Update rate of sensors"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"Why is it important to model sensor noise in simulation?"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"A) It makes the simulation look more realistic"}),"\n",(0,a.jsx)(e.li,{children:"B) It helps algorithms work better in the real world"}),"\n",(0,a.jsx)(e.li,{children:"C) It increases simulation speed"}),"\n",(0,a.jsx)(e.li,{children:"D) It reduces computational requirements"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Answers"}),": 1-C, 2-B, 3-C, 4-B, 5-B"]})]})}function m(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>o,x:()=>t});var s=i(6540);const a={},r=s.createContext(a);function o(n){const e=s.useContext(r);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function t(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:o(n.components),s.createElement(r.Provider,{value:e},n.children)}}}]);