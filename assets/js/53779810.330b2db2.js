"use strict";(globalThis.webpackChunkai_robotics_book=globalThis.webpackChunkai_robotics_book||[]).push([[3629],{1207:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module3_isaac/isaac-navigation-nav2","title":"Isaac Navigation with Nav2","description":"Learning Objectives","source":"@site/docs/module3_isaac/14-isaac-navigation-nav2.md","sourceDirName":"module3_isaac","slug":"/module3_isaac/isaac-navigation-nav2","permalink":"/Physical-AI-and-Humanoid-Robotics-Book/docs/module3_isaac/isaac-navigation-nav2","draft":false,"unlisted":false,"editUrl":"https://github.com/Iqrasajid-01/docs/module3_isaac/14-isaac-navigation-nav2.md","tags":[],"version":"current","sidebarPosition":14,"frontMatter":{"title":"Isaac Navigation with Nav2","sidebar_label":"14 - Isaac Navigation with Nav2"},"sidebar":"tutorialSidebar","previous":{"title":"13 - Isaac Perception Systems","permalink":"/Physical-AI-and-Humanoid-Robotics-Book/docs/module3_isaac/isaac-perception-systems"},"next":{"title":"15 - Isaac ROS Integration","permalink":"/Physical-AI-and-Humanoid-Robotics-Book/docs/module3_isaac/isaac-ros-integration"}}');var s=a(4848),t=a(8453);const r={title:"Isaac Navigation with Nav2",sidebar_label:"14 - Isaac Navigation with Nav2"},o="Isaac Navigation with Nav2",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Navigation2 (Nav2) Stack",id:"navigation2-nav2-stack",level:3},{value:"Isaac Navigation Enhancements",id:"isaac-navigation-enhancements",level:3},{value:"Navigation Pipeline Architecture",id:"navigation-pipeline-architecture",level:3},{value:"Jetson-Optimized Navigation",id:"jetson-optimized-navigation",level:3},{value:"Architecture Diagram",id:"architecture-diagram",level:2},{value:"Flow Diagram",id:"flow-diagram",level:2},{value:"Code Example: Isaac-Enhanced Navigation Node",id:"code-example-isaac-enhanced-navigation-node",level:2},{value:"Isaac Navigation Configuration",id:"isaac-navigation-configuration",level:2},{value:"Step-by-Step Practical Tutorial",id:"step-by-step-practical-tutorial",level:2},{value:"Setting up Isaac Navigation with Nav2",id:"setting-up-isaac-navigation-with-nav2",level:3},{value:"Summary",id:"summary",level:2},{value:"Mini-Quiz",id:"mini-quiz",level:2}];function p(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"isaac-navigation-with-nav2",children:"Isaac Navigation with Nav2"})}),"\n",(0,s.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Understand how NVIDIA Isaac enhances the ROS2 Navigation2 (Nav2) stack"}),"\n",(0,s.jsx)(e.li,{children:"Configure and optimize Isaac-optimized navigation pipelines"}),"\n",(0,s.jsx)(e.li,{children:"Implement GPU-accelerated path planning and obstacle avoidance"}),"\n",(0,s.jsx)(e.li,{children:"Integrate Isaac perception systems with navigation capabilities"}),"\n",(0,s.jsx)(e.li,{children:"Deploy navigation systems on Jetson platforms for autonomous robots"}),"\n",(0,s.jsx)(e.li,{children:"Evaluate and tune navigation performance for different environments"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(e.p,{children:"Navigation is a fundamental capability for autonomous robots, enabling them to move safely and efficiently through complex environments. The ROS2 Navigation2 (Nav2) stack provides a comprehensive framework for robot navigation, and NVIDIA Isaac adds GPU-accelerated optimizations that significantly enhance performance for AI-powered robots."}),"\n",(0,s.jsx)(e.p,{children:"Isaac's navigation capabilities combine traditional robotics algorithms with modern AI techniques, leveraging GPU acceleration for computationally intensive tasks like path planning, obstacle detection, and map building. This integration enables robots to navigate more intelligently and efficiently, particularly in dynamic and complex environments."}),"\n",(0,s.jsx)(e.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,s.jsx)(e.h3,{id:"navigation2-nav2-stack",children:"Navigation2 (Nav2) Stack"}),"\n",(0,s.jsx)(e.p,{children:"The Nav2 stack consists of several key components:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Global Planner"}),": Path planning from start to goal"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Local Planner"}),": Real-time obstacle avoidance and path following"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Costmap"}),": Representation of obstacles and drivable areas"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Controller"}),": Low-level motion control"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Recovery Behaviors"}),": Actions when navigation fails"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"isaac-navigation-enhancements",children:"Isaac Navigation Enhancements"}),"\n",(0,s.jsx)(e.p,{children:"Isaac adds several optimizations to Nav2:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"GPU-Accelerated Planning"}),": Fast path planning using CUDA"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Deep Learning Integration"}),": AI-based obstacle detection and classification"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Sensor Fusion"}),": Integration of multiple sensor modalities"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Simulation Integration"}),": Seamless sim-to-real transfer"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"navigation-pipeline-architecture",children:"Navigation Pipeline Architecture"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Localization"}),": Determining robot position in the map"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Mapping"}),": Building and updating environment maps"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Path Planning"}),": Computing optimal routes"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Path Execution"}),": Following computed paths while avoiding obstacles"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Recovery"}),": Handling navigation failures"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"jetson-optimized-navigation",children:"Jetson-Optimized Navigation"}),"\n",(0,s.jsx)(e.p,{children:"Navigation on Jetson platforms requires special considerations:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Power Efficiency"}),": Optimizing algorithms for limited power budgets"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Real-time Performance"}),": Ensuring timely response to obstacles"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Memory Management"}),": Efficient use of limited RAM"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Thermal Management"}),": Preventing overheating during intensive computation"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"architecture-diagram",children:"Architecture Diagram"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"Flow Diagram",src:a(7869).A+"",width:"1445",height:"750"})}),"\n",(0,s.jsx)(e.h2,{id:"flow-diagram",children:"Flow Diagram"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"Flow Diagram",src:a(3954).A+"",width:"1064",height:"465"})}),"\n",(0,s.jsx)(e.h2,{id:"code-example-isaac-enhanced-navigation-node",children:"Code Example: Isaac-Enhanced Navigation Node"}),"\n",(0,s.jsx)(e.p,{children:"Here's an example of a navigation node that integrates Isaac enhancements:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PoseStamped, Twist\nfrom nav_msgs.msg import Odometry, OccupancyGrid\nfrom sensor_msgs.msg import LaserScan, PointCloud2\nfrom visualization_msgs.msg import MarkerArray\nfrom std_msgs.msg import String, Bool\nfrom builtin_interfaces.msg import Duration\nimport numpy as np\nimport math\nfrom scipy.spatial import distance\nimport torch\nimport torch.nn as nn\nfrom tf2_ros import TransformListener, Buffer\nfrom tf2_geometry_msgs import do_transform_pose\nimport tf2_py as tf2\nfrom geometry_msgs.msg import TransformStamped\nimport time\n\n\nclass IsaacNavigationNode(Node):\n    """\n    Isaac-enhanced navigation node with GPU-accelerated components\n    """\n\n    def __init__(self):\n        super().__init__(\'isaac_navigation_node\')\n\n        # Initialize parameters\n        self.declare_parameter(\'planner_frequency\', 5.0)\n        self.declare_parameter(\'controller_frequency\', 20.0)\n        self.declare_parameter(\'max_linear_speed\', 0.5)\n        self.declare_parameter(\'max_angular_speed\', 1.0)\n        self.declare_parameter(\'min_obstacle_distance\', 0.5)\n        self.declare_parameter(\'goal_tolerance\', 0.2)\n        self.declare_parameter(\'use_gpu_planning\', True)\n\n        # Get parameters\n        self.planner_frequency = self.get_parameter(\'planner_frequency\').value\n        self.controller_frequency = self.get_parameter(\'controller_frequency\').value\n        self.max_linear_speed = self.get_parameter(\'max_linear_speed\').value\n        self.max_angular_speed = self.get_parameter(\'max_angular_speed\').value\n        self.min_obstacle_distance = self.get_parameter(\'min_obstacle_distance\').value\n        self.goal_tolerance = self.get_parameter(\'goal_tolerance\').value\n        self.use_gpu_planning = self.get_parameter(\'use_gpu_planning\').value\n\n        # Initialize TF2\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, self)\n\n        # Initialize variables\n        self.current_pose = None\n        self.current_twist = None\n        self.goal_pose = None\n        self.global_path = []\n        self.local_path = []\n        self.obstacles = []\n        self.map_data = None\n\n        # GPU setup\n        self.device = torch.device(\'cuda\' if torch.cuda.is_available() and self.use_gpu_planning else \'cpu\')\n        self.get_logger().info(f\'Navigation using device: {self.device}\')\n\n        # Create publishers\n        self.cmd_vel_pub = self.create_publisher(Twist, \'/cmd_vel\', 10)\n        self.path_pub = self.create_publisher(MarkerArray, \'/navigation/path\', 10)\n        self.status_pub = self.create_publisher(String, \'/navigation/status\', 10)\n\n        # Create subscribers\n        self.odom_sub = self.create_subscription(\n            Odometry, \'/odom\', self.odom_callback, 10)\n        self.goal_sub = self.create_subscription(\n            PoseStamped, \'/goal_pose\', self.goal_callback, 10)\n        self.scan_sub = self.create_subscription(\n            LaserScan, \'/scan\', self.scan_callback, 10)\n        self.map_sub = self.create_subscription(\n            OccupancyGrid, \'/map\', self.map_callback, 10)\n\n        # Create timers\n        self.planner_timer = self.create_timer(\n            1.0 / self.planner_frequency, self.plan_path)\n        self.controller_timer = self.create_timer(\n            1.0 / self.controller_frequency, self.execute_path)\n\n        # Initialize GPU-accelerated path planner\n        if self.use_gpu_planning:\n            self.path_planner = GPUPathPlanner(self.device)\n        else:\n            self.path_planner = CPUPathPlanner()\n\n        self.get_logger().info(\'Isaac Navigation Node initialized\')\n\n    def odom_callback(self, msg):\n        """\n        Handle odometry data\n        """\n        self.current_pose = msg.pose.pose\n        self.current_twist = msg.twist.twist\n\n    def goal_callback(self, msg):\n        """\n        Handle new goal pose\n        """\n        self.goal_pose = msg.pose\n        self.get_logger().info(f\'New goal received: ({msg.pose.position.x:.2f}, {msg.pose.position.y:.2f})\')\n\n        # Publish status\n        status_msg = String()\n        status_msg.data = \'new_goal_received\'\n        self.status_pub.publish(status_msg)\n\n    def scan_callback(self, msg):\n        """\n        Handle laser scan data for obstacle detection\n        """\n        # Convert laser scan to obstacle points\n        angle_min = msg.angle_min\n        angle_increment = msg.angle_increment\n\n        self.obstacles = []\n        for i, range_val in enumerate(msg.ranges):\n            if not (math.isnan(range_val) or math.isinf(range_val)):\n                if range_val < self.min_obstacle_distance + 0.5:  # Include some buffer\n                    angle = angle_min + i * angle_increment\n                    x = range_val * math.cos(angle)\n                    y = range_val * math.sin(angle)\n                    self.obstacles.append((x, y))\n\n    def map_callback(self, msg):\n        """\n        Handle map data\n        """\n        self.map_data = msg\n\n    def plan_path(self):\n        """\n        Plan global path to goal\n        """\n        if self.current_pose is None or self.goal_pose is None:\n            return\n\n        # Check if we\'re already at the goal\n        current_pos = (self.current_pose.position.x, self.current_pose.position.y)\n        goal_pos = (self.goal_pose.position.x, self.goal_pose.position.y)\n\n        distance_to_goal = math.sqrt((current_pos[0] - goal_pos[0])**2 + (current_pos[1] - goal_pos[1])**2)\n\n        if distance_to_goal < self.goal_tolerance:\n            self.get_logger().info(\'Reached goal position\')\n            self.stop_robot()\n            return\n\n        # Plan path using GPU if available\n        try:\n            start_time = time.time()\n\n            if self.use_gpu_planning and self.map_data:\n                # Convert map to tensor for GPU processing\n                map_tensor = self.occupancy_grid_to_tensor(self.map_data)\n                self.global_path = self.path_planner.plan_path_gpu(\n                    map_tensor, current_pos, goal_pos, self.device)\n            else:\n                # Fallback to CPU planning\n                self.global_path = self.path_planner.plan_path_cpu(current_pos, goal_pos)\n\n            planning_time = time.time() - start_time\n            self.get_logger().info(f\'Path planning completed in {planning_time*1000:.2f}ms\')\n\n            # Publish path visualization\n            self.publish_path_visualization()\n\n        except Exception as e:\n            self.get_logger().error(f\'Error in path planning: {e}\')\n\n    def execute_path(self):\n        """\n        Execute the planned path with obstacle avoidance\n        """\n        if self.current_pose is None or not self.global_path:\n            return\n\n        # Get current position\n        current_pos = (self.current_pose.position.x, self.current_pose.position.y)\n\n        # Check for obstacles in the path\n        if self.obstacles_in_path():\n            self.get_logger().warn(\'Obstacle detected in path, stopping robot\')\n            self.stop_robot()\n            return\n\n        # Calculate velocity command to follow path\n        cmd_vel = self.calculate_velocity_command(current_pos)\n\n        # Publish command\n        self.cmd_vel_pub.publish(cmd_vel)\n\n    def calculate_velocity_command(self, current_pos):\n        """\n        Calculate velocity command to follow the path\n        """\n        cmd_vel = Twist()\n\n        if not self.global_path:\n            return cmd_vel\n\n        # Find the closest point on the path\n        closest_idx = 0\n        min_dist = float(\'inf\')\n\n        for i, (x, y) in enumerate(self.global_path):\n            dist = math.sqrt((x - current_pos[0])**2 + (y - current_pos[1])**2)\n            if dist < min_dist:\n                min_dist = dist\n                closest_idx = i\n\n        # Target point ahead on the path\n        target_idx = min(closest_idx + 5, len(self.global_path) - 1)\n        target_x, target_y = self.global_path[target_idx]\n\n        # Calculate direction to target\n        dx = target_x - current_pos[0]\n        dy = target_y - current_pos[1]\n\n        # Calculate distance and angle\n        dist_to_target = math.sqrt(dx**2 + dy**2)\n        angle_to_target = math.atan2(dy, dx)\n\n        # Simple proportional controller\n        linear_speed = min(self.max_linear_speed, dist_to_target * 0.5)\n        angular_speed = angle_to_target * 1.0  # Proportional control\n\n        # Limit angular speed\n        angular_speed = max(-self.max_angular_speed, min(self.max_angular_speed, angular_speed))\n\n        cmd_vel.linear.x = linear_speed\n        cmd_vel.angular.z = angular_speed\n\n        return cmd_vel\n\n    def obstacles_in_path(self):\n        """\n        Check if there are obstacles blocking the path\n        """\n        if not self.global_path or not self.obstacles:\n            return False\n\n        # Check if any obstacle is close to the path\n        for path_x, path_y in self.global_path[:10]:  # Check first 10 points\n            for obs_x, obs_y in self.obstacles:\n                dist = math.sqrt((path_x - obs_x)**2 + (path_y - obs_y)**2)\n                if dist < self.min_obstacle_distance:\n                    return True\n\n        return False\n\n    def stop_robot(self):\n        """\n        Stop the robot\n        """\n        cmd_vel = Twist()\n        cmd_vel.linear.x = 0.0\n        cmd_vel.angular.z = 0.0\n        self.cmd_vel_pub.publish(cmd_vel)\n\n    def publish_path_visualization(self):\n        """\n        Publish path visualization\n        """\n        marker_array = MarkerArray()\n\n        # Create path line marker\n        path_marker = Marker()\n        path_marker.header.frame_id = \'map\'\n        path_marker.header.stamp = self.get_clock().now().to_msg()\n        path_marker.ns = \'navigation_path\'\n        path_marker.id = 0\n        path_marker.type = Marker.LINE_STRIP\n        path_marker.action = Marker.ADD\n\n        path_marker.pose.orientation.w = 1.0\n        path_marker.scale.x = 0.05  # Line width\n\n        path_marker.color.r = 0.0\n        path_marker.color.g = 1.0\n        path_marker.color.b = 0.0\n        path_marker.color.a = 0.8\n\n        # Add path points\n        for x, y in self.global_path:\n            point = path_marker.points.add()\n            point.x = x\n            point.y = y\n            point.z = 0.0\n\n        marker_array.markers.append(path_marker)\n        self.path_pub.publish(marker_array)\n\n    def occupancy_grid_to_tensor(self, occupancy_grid):\n        """\n        Convert occupancy grid to tensor for GPU processing\n        """\n        width = occupancy_grid.info.width\n        height = occupancy_grid.info.height\n        data = occupancy_grid.data\n\n        # Reshape data into 2D grid\n        grid = np.array(data).reshape((height, width))\n\n        # Convert to tensor\n        tensor = torch.tensor(grid, dtype=torch.float32, device=self.device)\n\n        return tensor\n\n\nclass GPUPathPlanner:\n    """\n    GPU-accelerated path planner using PyTorch\n    """\n\n    def __init__(self, device):\n        self.device = device\n        self.get_logger = lambda: print  # Simple logger for this class\n\n    def plan_path_gpu(self, map_tensor, start_pos, goal_pos, device):\n        """\n        Plan path using GPU acceleration\n        """\n        # This is a simplified example - in practice, you would implement\n        # a more sophisticated GPU-accelerated path planning algorithm\n        # like A* or Dijkstra\'s algorithm using CUDA operations\n\n        start_time = time.time()\n\n        # Convert positions to grid coordinates\n        # (Simplified - assumes map info is available)\n        start_grid = (int(start_pos[0]), int(start_pos[1]))\n        goal_grid = (int(goal_pos[0]), int(goal_pos[1]))\n\n        # For this example, return a straight line path\n        # In a real implementation, you would use GPU-accelerated path planning\n        path = self.straight_line_path(start_grid, goal_grid)\n\n        planning_time = time.time() - start_time\n        print(f\'GPU Path planning completed in {planning_time*1000:.2f}ms\')\n\n        return path\n\n    def straight_line_path(self, start, goal):\n        """\n        Simple straight line path (for demonstration)\n        """\n        path = []\n        steps = max(abs(goal[0] - start[0]), abs(goal[1] - start[1]))\n\n        if steps == 0:\n            return [start]\n\n        for i in range(steps + 1):\n            t = i / steps if steps > 0 else 0\n            x = start[0] + t * (goal[0] - start[0])\n            y = start[1] + t * (goal[1] - start[1])\n            path.append((x, y))\n\n        return path\n\n\nclass CPUPathPlanner:\n    """\n    CPU-based path planner (fallback)\n    """\n\n    def plan_path_cpu(self, start_pos, goal_pos):\n        """\n        Plan path using CPU\n        """\n        # Simple straight line path as fallback\n        path = []\n        steps = max(abs(goal_pos[0] - start_pos[0]), abs(goal_pos[1] - start_pos[1]))\n\n        if steps == 0:\n            return [start_pos]\n\n        for i in range(steps + 1):\n            t = i / steps if steps > 0 else 0\n            x = start_pos[0] + t * (goal_pos[0] - start_pos[0])\n            y = start_pos[1] + t * (goal_pos[1] - start_pos[1])\n            path.append((x, y))\n\n        return path\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    navigation_node = IsaacNavigationNode()\n\n    try:\n        rclpy.spin(navigation_node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        navigation_node.stop_robot()\n        navigation_node.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,s.jsx)(e.h2,{id:"isaac-navigation-configuration",children:"Isaac Navigation Configuration"}),"\n",(0,s.jsx)(e.p,{children:"Here's an example of Isaac-optimized navigation configuration:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:'# navigation_config.yaml\nbt_navigator:\n  ros__parameters:\n    use_sim_time: false\n    global_frame: map\n    robot_base_frame: base_link\n    odom_topic: /odom\n    bt_loop_duration: 10\n    default_server_timeout: 20\n    enable_groot_monitoring: true\n    groot_zmq_publisher_port: 1666\n    groot_zmq_server_port: 1667\n    navigate_through_poses: false\n    navigate_to_pose: true\n    bt_xml_filename: "navigate_w_replanning_and_recovery.xml"\n    default_nav_through_poses_bt_xml: "navigate_w_replanning_and_recovery.xml"\n    default_nav_to_pose_bt_xml: "navigate_w_replanning_and_recovery.xml"\n\ncontroller_server:\n  ros__parameters:\n    use_sim_time: false\n    controller_frequency: 20.0\n    min_x_velocity_threshold: 0.001\n    min_y_velocity_threshold: 0.5\n    min_theta_velocity_threshold: 0.001\n    progress_checker_plugin: "progress_checker"\n    goal_checker_plugin: "goal_checker"\n    controller_plugins: ["FollowPath"]\n\n    # Isaac-specific controller\n    FollowPath:\n      plugin: "nav2_mppi_controller::MPPIController"\n      time_horizon: 1.0\n      dt: 0.05\n      vx_std: 0.2\n      vy_std: 0.2\n      wz_std: 0.3\n      speed_scaling_factor: 0.2\n      model_dt: 0.05\n      iteration_count: 30\n      enable_integration_correction: true\n      enable_average_trick: true\n      motion_model: "DiffDrive"\n      visualize_errors: true\n      transform_tolerance: 0.1\n      angular_dist_threshold: 0.785\n      forward_sampling_distance: 0.5\n      progress_checker: "progress_checker"\n      goal_checker: "goal_checker"\n\nlocal_costmap:\n  local_costmap:\n    ros__parameters:\n      update_frequency: 5.0\n      publish_frequency: 2.0\n      global_frame: odom\n      robot_base_frame: base_link\n      use_sim_time: false\n      rolling_window: true\n      width: 3\n      height: 3\n      resolution: 0.05\n      robot_radius: 0.22\n      plugins: ["voxel_layer", "inflation_layer"]\n      inflation_layer:\n        plugin: "nav2_costmap_2d::InflationLayer"\n        cost_scaling_factor: 3.0\n        inflation_radius: 0.55\n      voxel_layer:\n        plugin: "nav2_costmap_2d::VoxelLayer"\n        enabled: true\n        publish_voxel_map: true\n        origin_z: 0.0\n        z_resolution: 0.05\n        z_voxels: 16\n        max_obstacle_height: 2.0\n        mark_threshold: 0\n        observation_sources: scan\n        scan:\n          topic: /scan\n          max_obstacle_height: 2.0\n          clearing: true\n          marking: true\n          data_type: "LaserScan"\n          raytrace_max_range: 3.0\n          raytrace_min_range: 0.0\n          obstacle_max_range: 2.5\n          obstacle_min_range: 0.0\n\nglobal_costmap:\n  global_costmap:\n    ros__parameters:\n      update_frequency: 1.0\n      publish_frequency: 1.0\n      global_frame: map\n      robot_base_frame: base_link\n      use_sim_time: false\n      robot_radius: 0.22\n      resolution: 0.05\n      track_unknown_space: true\n      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]\n      obstacle_layer:\n        plugin: "nav2_costmap_2d::ObstacleLayer"\n        enabled: true\n        observation_sources: scan\n        scan:\n          topic: /scan\n          max_obstacle_height: 2.0\n          clearing: true\n          marking: true\n          data_type: "LaserScan"\n          raytrace_max_range: 3.0\n          raytrace_min_range: 0.0\n          obstacle_max_range: 2.5\n          obstacle_min_range: 0.0\n      static_layer:\n        plugin: "nav2_costmap_2d::StaticLayer"\n        map_subscribe_transient_local: true\n      inflation_layer:\n        plugin: "nav2_costmap_2d::InflationLayer"\n        cost_scaling_factor: 3.0\n        inflation_radius: 0.55\n\nplanner_server:\n  ros__parameters:\n    expected_planner_frequency: 20.0\n    use_sim_time: false\n    planner_plugins: ["GridBased"]\n    GridBased:\n      plugin: "nav2_navfn_planner::NavfnPlanner"\n      tolerance: 0.5\n      use_astar: false\n      allow_unknown: true\n      smooth_path: true\n      # Isaac-specific parameters\n      use_gpu_acceleration: true\n      max_iterations: 10000\n      max_on_grid_iterations: 1000\n      default_tolerance: 0.5\n\n# Isaac-specific navigation parameters\nisaac_navigation:\n  ros__parameters:\n    use_gpu_planning: true\n    planner_frequency: 5.0\n    controller_frequency: 20.0\n    max_linear_speed: 0.5\n    max_angular_speed: 1.0\n    min_obstacle_distance: 0.5\n    goal_tolerance: 0.2\n    enable_deep_obstacle_detection: true\n    perception_timeout: 1.0\n    recovery_enabled: true\n    recovery_behaviors: ["spin", "backup", "wait"]\n'})}),"\n",(0,s.jsx)(e.h2,{id:"step-by-step-practical-tutorial",children:"Step-by-Step Practical Tutorial"}),"\n",(0,s.jsx)(e.h3,{id:"setting-up-isaac-navigation-with-nav2",children:"Setting up Isaac Navigation with Nav2"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Install Isaac Navigation packages"})," (if not already installed):"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# This assumes you have Isaac ROS installed\nsudo apt update\nsudo apt install ros-humble-isaac-ros-nav2 ros-humble-isaac-ros-navigation\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Create a navigation package"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"cd ~/ros2_ws/src\nros2 pkg create --build-type ament_python isaac_navigation_examples --dependencies rclpy std_msgs geometry_msgs nav_msgs sensor_msgs visualization_msgs tf2_ros\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Navigate to the package directory"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"cd isaac_navigation_examples\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Create the main module directory"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"mkdir isaac_navigation_examples\ntouch isaac_navigation_examples/__init__.py\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Create the navigation node"})," (",(0,s.jsx)(e.code,{children:"isaac_navigation_examples/navigation_node.py"}),"):"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Use the Isaac navigation node code example above\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Create config directory"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"mkdir config\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Create navigation configuration"})," (",(0,s.jsx)(e.code,{children:"config/navigation_config.yaml"}),"):"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"# Use the configuration example above\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Create launch directory"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"mkdir launch\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Create a launch file"})," (",(0,s.jsx)(e.code,{children:"launch/isaac_navigation.launch.py"}),"):"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\nimport os\nfrom ament_index_python.packages import get_package_share_directory\n\n\ndef generate_launch_description():\n    # Declare launch arguments\n    use_sim_time = LaunchConfiguration('use_sim_time', default='false')\n\n    # Get package share directory\n    pkg_share = get_package_share_directory('isaac_navigation_examples')\n    config_file = os.path.join(pkg_share, 'config', 'navigation_config.yaml')\n\n    return LaunchDescription([\n        # Declare launch arguments\n        DeclareLaunchArgument(\n            'use_sim_time',\n            default_value='false',\n            description='Use simulation time if true'),\n\n        # Isaac navigation node\n        Node(\n            package='isaac_navigation_examples',\n            executable='isaac_navigation_examples.navigation_node',\n            name='isaac_navigation_node',\n            parameters=[\n                config_file,\n                {'use_sim_time': use_sim_time}\n            ],\n            output='screen'\n        )\n    ])\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Update setup.py"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"from setuptools import setup\nimport os\nfrom glob import glob\n\npackage_name = 'isaac_navigation_examples'\n\nsetup(\n    name=package_name,\n    version='0.0.0',\n    packages=[package_name],\n    data_files=[\n        ('share/ament_index/resource_index/packages',\n            ['resource/' + package_name]),\n        ('share/' + package_name, ['package.xml']),\n        (os.path.join('share', package_name, 'launch'), glob('launch/*.py')),\n        (os.path.join('share', package_name, 'config'), glob('config/*.yaml')),\n    ],\n    install_requires=['setuptools'],\n    zip_safe=True,\n    maintainer='User',\n    maintainer_email='user@example.com',\n    description='Isaac navigation examples with GPU acceleration',\n    license='Apache-2.0',\n    tests_require=['pytest'],\n    entry_points={\n        'console_scripts': [\n            'navigation_node = isaac_navigation_examples.navigation_node:main',\n        ],\n    },\n)\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Build the package"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"cd ~/ros2_ws\ncolcon build --packages-select isaac_navigation_examples\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Source the workspace"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"source install/setup.bash\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Launch the navigation system"})," (requires CUDA-enabled GPU):"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"ros2 launch isaac_navigation_examples isaac_navigation.launch.py\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Send a navigation goal"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# In another terminal\nros2 run nav2_msgs action_client /navigate_to_pose\n# Then specify a goal pose\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Monitor navigation status"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# View navigation status\nros2 topic echo /navigation/status\n\n# View planned path\nros2 topic echo /navigation/path\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(e.p,{children:"This chapter covered Isaac's integration with the Navigation2 stack, demonstrating how GPU acceleration enhances navigation capabilities for autonomous robots. We explored the architecture of Isaac-optimized navigation systems, configuration options, and practical implementation techniques."}),"\n",(0,s.jsx)(e.p,{children:"Isaac's navigation enhancements enable robots to plan and execute paths more efficiently, particularly in complex environments where real-time obstacle detection and avoidance are critical. The combination of traditional navigation algorithms with GPU-accelerated processing provides superior performance for AI-powered robots."}),"\n",(0,s.jsx)(e.h2,{id:"mini-quiz",children:"Mini-Quiz"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"What is the primary benefit of GPU acceleration in navigation systems?"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"A) Lower cost"}),"\n",(0,s.jsx)(e.li,{children:"B) Faster path planning and obstacle processing"}),"\n",(0,s.jsx)(e.li,{children:"C) Simpler implementation"}),"\n",(0,s.jsx)(e.li,{children:"D) Reduced memory usage"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Which Nav2 component is responsible for path following and obstacle avoidance?"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"A) Global Planner"}),"\n",(0,s.jsx)(e.li,{children:"B) Local Planner"}),"\n",(0,s.jsx)(e.li,{children:"C) Controller"}),"\n",(0,s.jsx)(e.li,{children:"D) Costmap"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"What does the costmap represent in navigation?"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"A) Financial cost of navigation"}),"\n",(0,s.jsx)(e.li,{children:"B) Representation of obstacles and drivable areas"}),"\n",(0,s.jsx)(e.li,{children:"C) Map of charging stations"}),"\n",(0,s.jsx)(e.li,{children:"D) Network communication costs"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Which Isaac feature enhances obstacle detection in navigation?"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"A) GPU-accelerated perception"}),"\n",(0,s.jsx)(e.li,{children:"B) Traditional LIDAR only"}),"\n",(0,s.jsx)(e.li,{children:"C) Manual obstacle marking"}),"\n",(0,s.jsx)(e.li,{children:"D) Pre-programmed obstacle locations"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"What is the purpose of recovery behaviors in navigation?"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"A) To repair robot hardware"}),"\n",(0,s.jsx)(e.li,{children:"B) To handle navigation failures and get robot unstuck"}),"\n",(0,s.jsx)(e.li,{children:"C) To recharge robot batteries"}),"\n",(0,s.jsx)(e.li,{children:"D) To recalibrate sensors"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Answers"}),": 1-B, 2-B, 3-B, 4-A, 5-B"]})]})}function d(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(p,{...n})}):p(n)}},3954:(n,e,a)=>{a.d(e,{A:()=>i});const i=a.p+"assets/images/ch14-flow-b11a2d0fb5ed84bc4c6ac99da6e464b3.svg"},7869:(n,e,a)=>{a.d(e,{A:()=>i});const i=a.p+"assets/images/ch14-ad-75fc7a7c36a2754437e080e69688a508.svg"},8453:(n,e,a)=>{a.d(e,{R:()=>r,x:()=>o});var i=a(6540);const s={},t=i.createContext(s);function r(n){const e=i.useContext(t);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:r(n.components),i.createElement(t.Provider,{value:e},n.children)}}}]);